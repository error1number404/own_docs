[1] https://habr.com/ru/company/productivity_inside/blog/505430/
[2] https://proglib.io/p/solid-principy-chto-takoe-i-zachem-nuzhny-razbiraem-po-bukvam-2022-02-02
[3] https://medium.com/webbdev/solid-4ffc018077da

## S — Single Responsibility

Нужно разделять функциональность в разные классы, чтобы каждый из них отвечал за только свои обязанности.

_«Одно поручение. Всего одно.» — Локи говорит Скурджу в фильме «Тор: Рагнарёк».  
Каждый класс должен решать лишь одну задачу.

Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.

![[Single Responsibility.png]]


## O — Open-Closed

Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

Если понадобилось добавить новую функциональность к классу, то существующий класс не модифицируем, а создаем наследника класса с новыми возможностями. То есть у нас должна быть возможность расширять класс без изменения самого класса.

Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

![[Open Closed.png]]


## L — Liskov Substitution

Принцип подстановки Барбары Лисков, описывающий возможности заменяемости экземпляров объектов. Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
Простыми словами: дочерний класс должен следовать принципам родительского класса и не изменять их.

![[Liskov Substitution.png]]

В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок.  
  
Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью.  
  
Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу. На картинке это показано так: класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино (разновидность кофе), но неприемлемо подавать воду.  
  
Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип.

Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.


## I — Interface Segregation

Не следует ставить клиент в зависимость от методов, которые он не использует.

Создавайте узкоспециализированные интерфейсы и не вынуждайте клиента зависеть от неиспользуемых интерфейсов.

![[Interface Segregation.png]]

Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов.  
  
Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.

## D — Dependency Inversion

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

![[Dependency Inversion.png]]

Сущности должны зависеть от абстракций, а не от чего-то конкретного. Допустим, у нас есть низкоуровневый класс `HTTPService` с логикой запроса и высокоуровневый класс `HTTP`, в конструктор которого мы передаем низкоуровневый модуль. После чего вызываем его методы и нарушаем принцип инверсии зависимости: высокоуровневый модель зависит от низкоуровневого. Для решения проблемы мы создаем отдельный интерфейс и передаем его в высокоуровневый интерфейс. Теперь наш класс не зависит от низкоуровневого модуля.

Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса.

Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.


## Послесловие

Если интересуют хорошие примеры кода, то в https://medium.com/webbdev/solid-4ffc018077da они довольно хорошо представлены

